#!/usr/bin/tclsh

source /usr/bin/gpio_control

#####################
# Variables         #
#####################
set ::MAX_BOARDS 16

#####################
# Helper Functions  #
#####################

proc print_help { } { 
    puts "Enable and disable Radio Front-End boards"
    puts "Arguments:"
    puts "    rfe_control <board_number> <on/off>"
    puts ""
    puts "    <board_number>: 0..15"
    puts "        This is the board number in the digital board."
    puts "    <on/off>:"
    puts "        Turn the RFE on or off"
    puts ""
}

proc check_inputs { board_number board_state } {
    if { $board_number < 0 || $board_number >= $::MAX_BOARDS } {
        puts "Unsupported board number."
        print_help
        exit
    }
    if { ![string equal $board_state "on"] && ![string equal $board_state "off"] } {
        puts "Unsupported board state."
        print_help
        exit
    }
}
#
#####################
# Main Function     #
#####################
if {$::argv0 eq [info script]} {
    set board_number 0
    set board_state off


    if { $::argc == 2 } {
        set board_number [lindex $::argv 0]
        set board_state [lindex $::argv 1]
    
        # Check validity of inputs
        check_inputs $board_number $board_state
    
    } else {
        puts "Invalid Arguments"
        print_help
        exit
    
    }

    set gpio_chip_label "pca9539"

    # The rfe control signals are not mapped one-to-one to the PCA9539 GPIO pins, therefore
    # the following table is used to correctly map an rfe control to it's GPIO pin.
    # For more information, see the backplane's schematic.
    set board_to_gpio_map_pwr_en [list 2 1 0 14 3 4 5 6 8 12 7 13 11 9 10 15]
    set board_to_gpio_map_board_good [list 6 7 8 15 5 4 3 2 10 14 1 12 11 0 13 9]

    # GPIO pin number that connects to Enable signal for this board
    set gpio_chip_number_pwr_en 0
    set en_gpio_pin_number [lindex $board_to_gpio_map_pwr_en $board_number]

    # GPIO pin number that connects to BoardGood signal for this board
    set gpio_chip_number_board_good 1
    set bg_gpio_pin_number [lindex $board_to_gpio_map_board_good $board_number]

    # Run main gpio code
    set en_gpio_file [get_gpio_file $gpio_chip_label $gpio_chip_number_pwr_en $en_gpio_pin_number]
    set bg_gpio_file [get_gpio_file $gpio_chip_label $gpio_chip_number_board_good $bg_gpio_pin_number]

    set board_good [gpio_in $bg_gpio_file]

    if { [string equal $board_state "on"] } {
        set_gpio_direction $en_gpio_file "high"

    } elseif { [string equal $board_state "off"] } {
        set_gpio_direction $en_gpio_file "low"
    }

    set board_good [gpio_in $bg_gpio_file]

    if { [string equal $board_state "off"] } {
        if { $board_good == 0 } {
            puts "Board was successfully powered down"
        } else {
            puts "ERROR: Board is still powered on!!!!"
        }
    } elseif { [string equal $board_state "on"] } {
        if { $board_good == 1 } {
            # if board was already on, don't wait
            puts "Board $board_number was successfully powered on"
        } else {
            puts "Reading the state of Board Good after 6 seconds ..."
            # wait for 6 seconds and read back the value of BoardGood
            after 6000
            set board_good [gpio_in $bg_gpio_file]
            if { $board_good == 1 } {
                puts "Board $board_number was successfully powered on"
            } else {
                puts "ERROR: Board $board_number did NOT power on!!!!"
            }
        }
    }
}
